# backend/app/adaptive/router.py
"""
Adaptive Strategy Router (AI Registry integration)

This router enhances the base signal generated by TradingEngine using:
- AI inference from Model Registry (active XGB/LGBM, optional)
- A safe adjustment logic that never breaks when models are missing
"""

from __future__ import annotations

from typing import Dict, Any, Optional

from app.ai.registry.runtime import predict_from_registry


class AdaptiveStrategyRouter:
    def __init__(self):
        pass

    @staticmethod
    def _action_from_score(score: float) -> str:
        if score >= 60:
            return "STRONG_BUY"
        if score >= 40:
            return "BUY"
        if score <= -60:
            return "STRONG_SELL"
        if score <= -40:
            return "SELL"
        return "NEUTRAL"

    async def enhance_signal(
        self,
        base_signal: Dict[str, Any],
        symbol: str,
        timeframe: str,
        features: Any,
        context: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Enhances the base signal score using AI registry inference if available.

        base_signal: output of TradingEngine._generate_signal
        context: contains db/timeframe + analysis snapshots
        """

        # If base signal is WAIT -> keep it
        if base_signal.get("action") == "WAIT":
            return base_signal

        base_score = float(base_signal.get("score") or 0.0)
        action = str(base_signal.get("action") or "NEUTRAL")

        # Pull db from context (TradingEngine passes it)
        db = None
        if isinstance(context, dict):
            db = context.get("db")

        # AI registry inference (returns None if no db or no active models)
        reg_pred = await predict_from_registry(
            db=db,
            symbol=symbol,
            timeframe=str(timeframe or "M15"),
            feature_vector=features,
        )

        # Default AI result (safe)
        ai_direction = "neutral"
        ai_prob = 0.5
        ai_used_models = {}
        ai_probs = {}
        ai_notes = ["no_active_registry_models"]

        if reg_pred is not None:
            ai_direction = reg_pred.direction
            ai_prob = float(reg_pred.prob)
            ai_used_models = reg_pred.used_models
            ai_probs = reg_pred.probs
            ai_notes = reg_pred.notes

        # Score adjustment logic
        ai_adj = 0.0
        # Convert action to candidate side
        cand_buy = ("BUY" in action)
        cand_sell = ("SELL" in action)

        # If signal is neutral but AI is strong, we allow small nudge (not a full reversal)
        if action == "NEUTRAL":
            if ai_direction == "bullish" and ai_prob >= 0.65:
                ai_adj += 8.0 * (ai_prob - 0.5) / 0.5
            elif ai_direction == "bearish" and ai_prob >= 0.65:
                ai_adj -= 8.0 * (ai_prob - 0.5) / 0.5
        else:
            if cand_buy:
                if ai_direction == "bullish":
                    ai_adj += 10.0 * (ai_prob - 0.5) / 0.5
                elif ai_direction == "bearish":
                    ai_adj -= 14.0 * (ai_prob - 0.5) / 0.5
            elif cand_sell:
                if ai_direction == "bearish":
                    ai_adj += 10.0 * (ai_prob - 0.5) / 0.5
                elif ai_direction == "bullish":
                    ai_adj -= 14.0 * (ai_prob - 0.5) / 0.5

        # Final score + action
        final_score = float(base_score + ai_adj)
        final_action = self._action_from_score(final_score)
        final_confidence = min(100, abs(final_score))

        # Merge into signal structure (keep previous fields)
        out = dict(base_signal)
        out["score"] = final_score
        out["action"] = final_action
        out["confidence"] = final_confidence

        # Attach adaptive metadata
        adaptive = dict(out.get("adaptive") or {})
        adaptive.update({
            "base_score": base_score,
            "ai_adj": ai_adj,
            "ai": {
                "mode": "registry",
                "direction": ai_direction,
                "prob": ai_prob,
                "used_models": ai_used_models,
                "probs": ai_probs,
                "notes": ai_notes,
            },
        })
        out["adaptive"] = adaptive

        return out